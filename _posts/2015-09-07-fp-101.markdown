---

layout: post

categories: [fp]

title: Functional Programming 101

---

First things first - this is absolutely a work in progress. It is nowhere near completion.

# Function Programming 101

Functional programming is about

* Functions, first and foremost
* Immutable data
* Isolating effects (mutable data, calls to the outside world, and concurrency - yes, concurrency is an effect)
* DRY (Don't Repeat Yourself) to the **MAX**.

If you don't know what those things are, that's okay - you're going to learn them if you read this book. If you do know, but have been stumped a few times trying to understand it, you've come to the right place.

## Functions

Let's dive into the universe of functions.

We could do it in a rigorous, mathematical, dry way. We could explain domains and ranges, on-to-one, onto, etc. But let's not do that. Instead, let's have fun - let's talk about machines. Machines are fun, and easy, and everyone is familiar with them.

<img src="http://joshcough.github.io/images/MachinesQuestion.png" alt="Paper Shredder" title="" height="50%" width="50%"/>

The answer is simple - machines *are* functions, and they are a super simple way to start learning about functions, types, and other important functional programming concepts.

There are three basic kinds of machines.

* Regular machines (Input-Output machines)
* Output-Only machines
* Input-Only machines

### Regular Machines

Regular machines are what we typically think of as machines - some mechanical device that takes in some input, does something with it, and spits something out. Here's a simple way to picture a machine in your mind.

<img src="http://joshcough.github.io/images/RegularMachine.png" alt="Regular Machine" title="" height="50%" width="100%"/>

But, that doesn't look fun, or happy. When I think of functions and machines, I like to imagine this:

<img src="http://joshcough.github.io/images/HappyFunction.png" alt="Happy Function" title="" height="50%" width="50%"/>

Most machines are regular machines, and almost all of our programs (and the functions in our programs) are regular machines too. In functional programming, we think almost *exclusively* in terms of regular machines! For that reason, we are going to concentrate mostly on these types of machines. But, the other types of machines are very important too.

Let's look at a few examples of simple machines. For each machine, think hard about what type of input it takes, and what type of output it emits.

* A paper shredder is a simple machine. You put paper into it, and shredded paper comes out. Some of them are more powerful than others. Maybe there are some that can only shred a single piece of paper at a time. Maybe a super powerful one could shred a magazine, or even a whole paperback book.

<img src="http://joshcough.github.io/images/PaperShredder.png" alt="Paper Shredder" title="" height="50%" width="50%"/>

* A wood chipper is a paper shredder on steroids. It could easily shred paper, and paperback books, but also hard cover books, twigs, and even whole trees. It spits out pulp.
* A printer is another machine that takes paper as an input. But, it also needs additional inputs - mainly ink, and some document to print. It takes the paper, and uses the document to figure out where to put the ink on the page. It when spits out a pretty page.
* A dishwasher takes dishes (typically dirty dishes, but it accepts clean ones too), and it outputs clean dishes.
* Even a human is a machine! Food goes in, and, well...you get the idea. You should come up with some more simple machines.

#### Code example

Let's see what a paper shredder like in Scala.

If we imagine a piece of paper as a String with multiple lines, then a paper shredder is a machine that gets a list containing all the lines in that String.

```def shred(paper: String): List[String] = paper.split("\\n")```

Let's break down the syntax so that it isn't intimidating.

* `def` stands for define or definition. It means that you are defining a function.
* `shred` is the name of the function.
* `(input: String)` is the argument list. `shred` only takes on argument. Later we'll show functions that take more than one argument.
  * `paper` is the name of the first argument. In Scala, the name always comes before the type of the argument.
  * `:` - the colon is just a separator between the name and the type. Otherwise, it has no meaning.
  * `String` is the type of the argument (`paper`).
* `:` - the next colon is also just a separator. In this case, it indicates that the return type of the function is coming next.
* `List[String]` is the return type of the function. `List[String]` means List of Strings, or a List that can only contain Strings.
* `=` everything on the left of the `=` is the metadata for the function (name, input, output, etc). Everything to the right of the `=` is the *body* of the function.
* `paper.split("\n")` is the body of the function. In this case, we assume that some split function exists on String.

<img src="http://joshcough.github.io/images/ScalaSyntax.png" alt="Scala Syntax" title="" height="75%" width="100%"/> This image needs to have the arrows reversed.

#### A quick thought about immutability

So that we don't get off on the wrong foot, let's pause just a second to think about immutability. When we think about machines (especially regular machines), we can think of them in two different ways.

* Machines that take their input, and modify it directly

or...

* Machines that take their input and create some output using that input.

The former is, for the most part, what happens in the real world with real machines. Imperative programmers tend to use a mix of the two views (Strings are immutable in Java, for example, but StringBuffers are mutable). But functional programmers *almost always* tend to think in terms of the latter. Inputs to functions are **immutable** - they can't be modified, so new data must be created to be returned.

Now, we'll be the first to admit, this might be a *just a little* counterintuitive. But hang in there. By the end of the book, it will be second nature.

### Output-Only machines

Output-Only machines are machines that take no output but still spit things out. We might also call these Sources, or Generators.

<img src="http://joshcough.github.io/images/OutputOnlyMachine2.png" alt="Output-Only Machine" title="" height="50%" width="75%"/>

* The Big Bang is definitely one of these. It spits out the entire universe (holy &@*%!), seemingly with no inputs at all.
* The sun is kind of like this - it spits out light and heat. You could argue that its inputs are hydrogen particles and other particles, but, you could also argue that those particles are just simply there, and via the forces of nature, light and heat come out.
* Books (once printed) are powerful machines that output ideas.

As a fun exercise, you should try to think of some yourself.

A real world programming example would be a function that reads from a file system. You might say, "Hey, it has the file system as input", and you'd be right. But from the point of view of your program, the function only outputs data. We draw the line when a function has to go to the outside world to get data. We'll have a lot more to say about Output-Only machines later, because they are more complicated than regular machines.

### Input-Only machines

Input-Only machines are machines that *only* take input, and *never* spit anything out.

<img src="http://joshcough.github.io/images/InputOnlyMachine2.png" alt="Input-Only Machine" title="" height="50%" width="75%"/>

For some of these examples, you have to suspend disbelief a bit, but that's ok, were just having fun.

* Black Holes take in matter, and it never comes out (let's pretend Hawking radiation didn't exist!).
* A sink takes in some water (and maybe some bits of food) and, nothing really ever comes out (This is that part where you have to suspend disbelief - obviously something comes out somewhere, but from our point of view, nothing ever comes out).
* Like a sink, a toilet is a pretty obvious example. I won't bother with the input here :)

Once again, try to think of some. It's fun!

As you might have guessed, input-only machines are the opposite of output only machines. A real world programming example would be a function that *writes* to a file system. Once again, we draw the line when a function has to go to the outside world to write data (or do anything). As with Output-Only machines we'll have a lot more to say about Input-Only machines later. They are also more complicated than regular machines.

## Connecting machines

One **super duper** important thing about machines is that you can hook them together in all sorts of different ways.

* Water treatment plant - Unfiltered water goes into a water treatment plant, and a little while later, clean water comes out (lots of machines are used to make this happen).
* Dog - Water goes into a dogs mouth, and a bit later, the dog marks his territory.

When we hook these two machines together - the treatment plant and the dog - we get a machine that takes unfiltered, and produces dirty water.

This is called **composition**, and functions are __great__ at it.

<img src="http://joshcough.github.io/images/FunctionComposition.png" alt="Input-Only Machine" title="" height="50%" width="100%"/>

One very interesting point with this example is that not only can you hook these machines together was we did, but you can also hook the dog back up to the water treatment plant, creating a never ending cycle :) We'll have more to say about this later too.

### Important point

Composition really is the essence of programming. We write little functions, connect them together to make bigger functions, and so on, until we have a working program. For example, if you connect an output-only machine to a regular machine to input-only machine, thatâ€™s a whole program.

<img src="http://joshcough.github.io/images/WholeProgram.png" alt="Input-Only Machine" title="" height="50%" width="100%"/>

One good example of this is a compiler. A compiler is Output-Only machine (spewing out data from files on the file system), connected to a Regular Machine (files go through the parser, then type checker, then code generator), connected to an Input-Only machine that writes out compiled files to disk.

## Inside machines

There's something else that is super cool about our water treatment example. Both of those machines have a *lot* of internal machinery, but we don't have to know about it at all! Think about it - you probably don't know what happens inside a water treatment plant (or even where the water comes from). You might not even know what happens to the water after it goes into the dog's mouth. This is okay! Not having to know what is inside is essential to many of our programming tasks. This is typically called abstraction and/or encapsulation (they are complementary) and functions are also really great at those.

Functions very nice tools for composition, abstraction, encapsulation. This goes for things very small, and very, very large complex. You may have heard the term "functions in the small, objects in the large". Functional programmers find that to be false. We live by functions in the small, and functions in the large.
