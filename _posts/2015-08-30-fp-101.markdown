---
layout: post
categories: [fp]
title: Functional Programming 101
---

# Function Programming 101

Functional programming is about

* Functions, first and foremost
* Immutable data
* Isolating effects (mutable data, calls to the outside world, and concurrecy - yes, concurrency is an effect)

## Functions

Let's dive into the universe of functions.

We could do it in a rigorous, mathematical, dry way. We could explain domains and ranges, on-to-one, onto, etc. But let's not do that. You might be familiar with some of these things, but you simply don't care. You don't want to hear it that way. I don't want to write about it that way either.

### Input-to-Output Machines

Instead, let's take a playful approach - functions are machines and machines are functions. Everyone, even 2 year olds know about machines. They are fun and easy. Typically, you put something into a machine and something comes out. Those are the kind of machines that we'll mostly be thinking about for now. But, there are two other kinds of machines - machines that take no input, but spit things out anyway, and machines that take input, but never spit anything out.

Let's look at a few examples of simple machines.

* A paper shredder is a simple machine. You put paper into it, and shredded paper comes out. Some of them are more powerful than others. Many there are some that can only shred a single piece of paper at a time. Maybe a super powerful one could shred a magazine, or even a whole paperback book.
* A wood chipper is a paper shredder on steroids. It could easily shred paper, and paperback books, but also hard cover books, twigs, and even whole trees.
* A printer is another machine that takes paper as an input. But, it also needs additional inputs - mainly ink, and some document to print. It takes the paper, and uses the document to figure out where to put the ink on the page. It when spits out a pretty page.
* A dishwasher takes dishes (typically dirty dishes, but it accepts clean ones too), and it outputs clean dishes.
* Even a human is a machine! Food goes in, and, well...you get the idea.

You should come up with some more simple machines.

#### A quick thought about immutability

So that we don't get off on the wrong foot, let's pause just a second to think about immutability. When it comes to these kinds of machines, you can think of them in two different ways.

* Machines that take their input, and modify it directly

 or...

* Machines that take their input and create some output using that input.

Functional programmers almost always tend to think in terms of the latter. For the most part, inputs can't be modified. Let's think about our machines again really quick.

* For a paper shredder, you put in a piece of paper, and get back some shredded paper. But, you still have your original piece of paper!
* Wood chipper too - you could put in a whole forest, and get a mountain of pulp, but still have your whole forest too!
* For a dishwaser, you put in dirty dishes, and get back ... dirty dishes and clean dishes! That's a little weird, we know. You don't want the dirty dishes, and that is perfectly fine. You can throw them in the garbage!
* And finally, beer goes in, and pee comes out, but you still have your beer!! In this case, you don't really want the pee, but having the beer is **AWESOME**!

Now, we'll be the first to admit, this might be a __just a little__ counterintuative. But hang in there. By the end of the book, it will be second nature.

### Output only machines

There are more complex machines that take no output but still spit things out. We shouldn't focus on these too much for now, but we will later. But, let's see if we can think of some quick examples.

* The Big Bang is definitely one of these. It spit out the entire universe (!!) Seemingly with no inputs at all.
* The sun is kind of like this - it spits out light and heat. You could argue that its inputs are hyrogen and other particles, but, you could also argue that those particles are just simply there, and via the forces of nature, light and heat come out.
* Books (once printed) are powerful machines that output ideas.

We'll come back to those kind of machines later. But, as a fun exercise, you should try to think of some yourself.

### Input only machines

As with output only machines, we'll also not concentrate too much on input-only machines. But still, a few examples are fun. For some of these examples, you have to suspend disbelief a bit, but that's ok, were just having fun.

* Black Holes take in matter, and it never comes out (let's pretend Hawking radition didn't exist!).
* A sink takes in some water (and maybe some bits of food) and, nothing really ever comes out (This is that part where you have to suspend disbelief - obviously something comes out somwhere, but from our point of view, nothing ever comes out).
* Like a sink, a toilet is a pretty obvious example. I won't bother with the input here :)

We'll also come back to these later, but once again, try to think of some. It's fun!

## Connecting machines

One __super duper__ important thing about machines is that you can hook them together in all sorts of different ways.

* Brewery - The ingredients of beer (water, barely, yeast, hops), go into the brewery and a little while later, beer comes out (lots of machines are used to make this happen).
* Human - Beer goes into a human mouth, and a bit later, pee comes out (and some questionable judgement).

When we hook these two machines together - the brewery and the human - we get a machine that takes the ingredients for beer, and produces pee (and sometimes some other humans).

This is called **composition**, and functions are __great__ at it.

## Inside machines

There's something else that is super cool about our brewery example.

Both of those machines have a __lot__ of internal machinery, but we don't have to know about it at all! Think about it - you probably don't know what happens inside a brewery. Heck, you might not even know what happens to the beer after it goes into your mouth. This is okay!

Not having to know what is inside is essential to many of our programming tasks.

This is typically called abstraction and/or encapsulation (they are complementary) and functions are also really great at those.

Functions very nice tools for composition, abstraction, encapsulation. This goes for things very small, and very, very large complex. You may have heard the term "functions in the small, objects in the large". Functional programmers find that to be false. We live by functions in the small, and functions in the large.



